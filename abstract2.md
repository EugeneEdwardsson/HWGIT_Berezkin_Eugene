# Лекция 2

# Цель лекции:

## Освоить создание веток в GitHub

## **Ветки позволяют легко управлять черновиками и чистовиками в Git.**

## **Имена файлов обязательно указываем  с расширениями и не «теряем» пробелы!!!**

## **Имена файлов обязательно указываем  с расширениями и не «теряем» пробелы!!!**

## Конфликт изменений

## При работе в двух ветках одновременно может возникнуть ситуация, когда в одной и другой ветке мы по-разному изменили блок текста. Если затем мы попробуем слить эти ветки, Git сообщит о конфликте и предложит выбрать, какие же изменения записать.

**Поэтому у проекта в репозитории должен быть один ответственный пользователь, наделённый правом проводить слияния и разрешать конфликты.**

[**Основные команды:**](https://www.notion.so/7042cbcd508a4efb96e3d6bb5d478492)

[**Работа с версиями файла**](https://www.notion.so/0d8dc01a7b6d41eaa72660d63b486f6b)

[Операция слияния веток](https://www.notion.so/fc7243f212a94e5ab361d853c619218b)


# Визуализация всех веток

# git log --graph 
## Ключ -graph в связке с командой log позволяет отобразить коммиты в виде дерева.


# **Работа с версиями файла**

## git branch

### Если у нас несколько версий черновика, мы можем вывести на экран ветку, где находимся, командой git branch.

# Если у нас несколько версий черновика, мы можем вывести на экран ветку, где находимся, командой git branch.

# **Если потребуется переключиться с одной ветки на другую, вызовем команду git checkout <имя ветки>**

Когда мы правим текст/код в текущей ветке, автоматического слияния не происходит: можно создавать один документ в разных версияхв разных ветках.

Когда мы правим текст/код в текущей ветке, автоматического слияния не происходит: можно создавать один документ в разных версиях в разных ветках.


# Операция слияния веток

Merge

Наличие нескольких веток чрезвычайно удобно для того, чтобы новые изменения были отделены друг от друга, а также чтобы вы случайно не запушили несанкционированные или поврежденные изменения в продакшин. Как только изменения будут одобрены, мы хотим получить эти изменения в нашей прод ветке!

Один из способов получить изменения из одной ветки в другую - выполнить git merge! Есть два типа мердж команд, которые может выполнять Git: fast-forward или no-fast-forward

Fast-forward (--ff)

Fast-forward merge когда текущая ветка не имеет дополнительных коммитов по сравнению с веткой, которую мы мержим. Git у нас ленив и сначала попытается выполнить самый простой вариант: Fast-forward! Этот тип менжа не создает новый коммит, а скорее объединяет коммит(ы) в ветку, которую мы объединяем прямо в текущей ветке

No-fast-foward (--no-ff)

Хорошо, если ваша текущая ветка не имеет каких-либо дополнительных коммитов по сравнению с веткой, которую вы хотите смержить, но, к сожалению, это случается редко! Если мы зафиксировали изменения в текущей ветке, которых нет в ветке, которую мы хотим объединить, git выполнит объединение без fast-forward merge. При слиянии без fast-forward Git создает новый коммит мержа в активную ветку. Родительский коммит указывает на активную ветку и ветку, которую мы хотим объединить!

Merge конфликты

Хотя Git хорошо решает, как объединять ветки и добавлять изменения в файлы, он не всегда может принять это решение сам по себе. Это может произойти, когда две ветки, которые мы пытаемся смержить, имеют изменения в одной строке в одном и том же файле, или если одна ветка удалила файл, который изменила другая ветка, и так далее.


